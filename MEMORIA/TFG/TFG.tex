\documentclass[a4paper,11pt]{book}
%\documentclass[a4paper,twoside,11pt,titlepage]{book}
\usepackage{listings}
\usepackage[utf8]{inputenc}
\usepackage[spanish]{babel}

% \usepackage[style=list, number=none]{glossary} %
%\usepackage{titlesec}
%\usepackage{pailatino}

\decimalpoint
\usepackage{dcolumn}
\newcolumntype{.}{D{.}{\esperiod}{-1}}
\makeatletter
\addto\shorthandsspanish{\let\esperiod\es@period@code}
\makeatother


%\usepackage[chapter]{algorithm}
\RequirePackage{verbatim}
%\RequirePackage[Glenn]{fncychap}
\usepackage{fancyhdr}
\usepackage{graphicx}
\usepackage{afterpage}

\usepackage{longtable}

\usepackage[pdfborder={000}]{hyperref} %referencia



% ********************************************************************
% Re-usable information
% ********************************************************************
\newcommand{\myTitle}{Beamformer acústico}
\newcommand{\myDegree}{Grado en Ingeniería de Tecnologías de Telecomunicación\xspace}
\newcommand{\myName}{Sergio Zapata Caparrós\xspace}
\newcommand{\myProf}{Antonio Miguel Peinado Herreros\xspace}
\newcommand{\myOtherProf}{Ángel Manuel Gómez García\xspace}
%\newcommand{\mySupervisor}{\xspace}
\newcommand{\myFaculty}{\xspace}
\newcommand{\myFacultyShort}{E.T.S. de Ingenierías Informática y de
Telecomunicación\xspace}
\newcommand{\myDepartment}{Departamento de ...\xspace}
\newcommand{\myUni}{\protect{Universidad de Granada}\xspace}
\newcommand{\myLocation}{Granada\xspace}
\newcommand{\myTime}{Granada, Julio de 2022\today\xspace}
\newcommand{\myVersion}{Version 0.1\xspace}


\hypersetup{
pdfauthor = {\myName (email (en) ugr (punto) es)},
pdftitle = {\myTitle},
pdfsubject = {},
pdfkeywords = {palabra_clave1, palabra_clave2, palabra_clave3, ...},
pdfcreator = {LaTeX con el paquete ....},
pdfproducer = {pdflatex}
}

%\hyphenation{}


%\usepackage{doxygen/doxygen}
%\usepackage{pdfpages}
\usepackage{url}
\usepackage{colortbl,longtable}
\usepackage[stable]{footmisc}
%\usepackage{index}

%\makeindex
%\usepackage[style=long, cols=2,border=plain,toc=true,number=none]{glossary}
% \makeglossary

% Definición de comandos que me son tiles:
%\renewcommand{\indexname}{Índice alfabético}
%\renewcommand{\glossaryname}{Glosario}

\pagestyle{fancy}
\fancyhf{}
\fancyhead[LO]{\leftmark}
\fancyhead[RE]{\rightmark}
\fancyhead[RO,LE]{\textbf{\thepage}}
\renewcommand{\chaptermark}[1]{\markboth{\textbf{#1}}{}}
\renewcommand{\sectionmark}[1]{\markright{\textbf{\thesection. #1}}}

\setlength{\headheight}{1.5\headheight}

\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}
%Definimos los tipos teorema, ejemplo y definición podremos usar estos tipos
%simplemente poniendo \begin{teorema} \end{teorema} ...
\newtheorem{teorema}{Teorema}[chapter]
\newtheorem{ejemplo}{Ejemplo}[chapter]
\newtheorem{definicion}{Definición}[chapter]

\definecolor{gray97}{gray}{.97}
\definecolor{gray75}{gray}{.75}
\definecolor{gray45}{gray}{.45}
\definecolor{gray30}{gray}{.94}

\lstset{ frame=Ltb,
     framerule=0.5pt,
     aboveskip=0.5cm,
     framextopmargin=3pt,
     framexbottommargin=3pt,
     framexleftmargin=0.1cm,
     framesep=0pt,
     rulesep=.4pt,
     backgroundcolor=\color{gray97},
     rulesepcolor=\color{black},
     %
     stringstyle=\ttfamily,
     showstringspaces = false,
     basicstyle=\scriptsize\ttfamily,
     commentstyle=\color{gray45},
     keywordstyle=\bfseries,
     %
     numbers=left,
     numbersep=6pt,
     numberstyle=\tiny,
     numberfirstline = false,
     breaklines=true,
   }
 
% minimizar fragmentado de listados
\lstnewenvironment{listing}[1][]
   {\lstset{#1}\pagebreak[0]}{\pagebreak[0]}

\lstdefinestyle{CodigoC}
   {
	basicstyle=\scriptsize,
	frame=single,
	language=C,
	numbers=left
   }
\lstdefinestyle{CodigoC++}
   {
	basicstyle=\small,
	frame=single,
	backgroundcolor=\color{gray30},
	language=C++,
	numbers=left
   }

 
\lstdefinestyle{Consola}
   {basicstyle=\scriptsize\bf\ttfamily,
    backgroundcolor=\color{gray30},
    frame=single,
    numbers=none
   }


\newcommand{\bigrule}{\titlerule[0.5mm]}


%Para conseguir que en las páginas en blanco no ponga cabecerass
\makeatletter
\def\clearpage{%
  \ifvmode
    \ifnum \@dbltopnum =\m@ne
      \ifdim \pagetotal <\topskip
        \hbox{}
      \fi
    \fi
  \fi
  \newpage
  \thispagestyle{empty}
  \write\m@ne{}
  \vbox{}
  \penalty -\@Mi
}
\makeatother

\usepackage{pdfpages}
\begin{document}
\input{portada/portada}
\input{prefacios/prefacio}
\frontmatter
\tableofcontents
%\listoffigures
%\listoftables
%
\mainmatter
\setlength{\parskip}{5pt}

\chapter{Introducción}
En este capítulo se realizará un fundamento teórico del concepto de ''Array Signal Processing'' y del método de ''Beamforming'', además de la utilidad en la realidad de estos términos. A parte, se argumentará la elección del proyecto en concreto y se explicará la distribución del mismo.
	\section{Procesamiento de señales multicanal}
	El procesamiento de señales multicanal, también conocido como ''Array Signal Processing'' se interpreta como un procesamiento de las señales en el espacio y en el tiempo.
	
	Conforme se va incrementando en frecuencia, las antenas necesitan unas dimensiones eléctricas mayores y se empiezan a alejar de las geometrías lineales. Para conformar la radiación y llegar a conseguir frentes de onda que puedan generar directividades elevadas y diagramas de radiación concretos, se presenta las llamadas 'Aperturas'. La respuesta procedente de una apertura es direccional, es decir, la señal recibida en la apertura depende de la dirección de llegada (DOA). El diagrama de radiación de una apertura lineal uniforme de longitud 'L' se muestra en la \textit{Figura 1.1}.
	\begin{figure}[hbtp]
	\centering
	\includegraphics[width = 8cm]{FIGURAS/directividad_apertura.JPG}
	\caption{Directividad apertura}
	\end{figure}
	
	 Se puede apreciar que actúa como un filtro espacial (fenómeno clave para hacer beamforming), diferenciándose claramente el lóbulo principal de los demás, menos directivos.
	 
	 Un array de sensores es, básicamente, una apertura conformada por un número de aperturas lineales, simulando de esta manera el comportamiento de una apertura lineal de longitud la suma de las longitudes de los elementos del array más la separación entre ellos. Por así decirlo, un array de sensores es una apertura muestreada en ciertas localizaciones. Un array lineal uniforme simula el comportamiento de una apertura lineal uniforme con una longitud $L = dN$ donde $d$ se corresponde a la distancia entre elementos y $N$ la longitud de estos. En la Figura 1.2 se puede observar un array lineal uniforme orientado sobre el eje $z$. Variando la longitud del array con una longitud de onda fija, se pueden lograr diferentes patrones de directividad, como son el ''endfire'' (con el máximo de directividad en 90º) y el ''broadside'' (con el máximo de directividad en 0º ó 180º.
	 \begin{figure}[hbtp]
	 \centering
	 \includegraphics[width = 5cm]{FIGURAS/array_elementos.JPG}
	 \caption{Agrupación de elementos}
	 \end{figure}
	 
	 El tipo de array que se va a tratar en el pryecto será un array Ad-Hoc de smartphones. Las agrupaciones de micrófonos consisten en un número de micrófonos los cuales se combinan para filtrar espacialmente las ondas acústicas. La configuración geométrica del array permitirá filtrar las señales deseadas para diversas aplicaciones. Este filtrado espacial sigue normalmente algoritmos de beamforming, los cuales se detallan en la siguiente sección. Sin embargo, para llegar al filtrado espacial, las señales captadas por los smartphones deben estar sincronizadas. Esto puede ser un problema, ya que el retardo producido desde que el primer móvil recibe la orden de grabar hasta que el último móvil recibe esta orden puede ser determinante. Además, las relojes de los móviles no se encuentran perfectamente sincronizados, por lo que se tendrá que implementar algún algoritmo de sincronización para mitigar estos efectos y llegar a realizar los filtros espaciales adecuadamente.
	 
	\section{Concepto de Beamforming}
	El concepto de ''Beamforming'' agrupa las técnicas necesarias para la determinación de filtros específicos, los cuales tienen el fin de obtener un patrón de directividad con una forma y dirección determinadas.
	
	Un ''beamformer'' se interpreta como un procesador, utilizado conjuntamente con una serie de sensores, para proporcionar una forma versátil de filtrado espacial. El objetivo es estimar la señal procedente de una dirección deseada, en un entorno ruidoso y en presencia de señales de interferencia. El ''beamformer'' actúa de forma similar a un filtro espacial, separando las señales que han sufrido una superposición en frecuencia, pero que se han originado en diferentes localizaciones espaciales.
	
	El caso que se planteará en este proyecto corresponde a un beamforming acústico. Dentro de este caso, existen dos ramas principales: una relacionada con la extracción de la señal y otra relacionada con la localización de las fuentes sonoras.
		\subsection{Tipos de Beamformers}
	\section{Impacto en la actualidad}
	El procesamiento de señales multicanal tiene múltiples aplicaciones. Algunas de ellas son: radioastronomía, radar, sismología, tomografía, comunicaciones inalámbricas, sonar y tratamiento de audio. Se explicará brevemente la actuación de este tipo de procesamiento para las comunicaciones celulares y para un punto de vista acústico.
		\subsection{Comunicaciones Inalámbricas}
		Las comunicaciones celulares en la actualidad emplean sectorización por células para proporcionar más frecuencias por área de cobertura.
		\begin{figure}[hbtp]
		\centering
		\includegraphics[width = 8cm]{FIGURAS/sectorización.JPG}
		\caption{Sectorización celular}
		\end{figure}
		
	
	Sin embargo, esta sectorización no fue suficiente para abarcar el creciente número de usuarios que solicitan recursos de frecuencia, por lo que, en la última generación estandarizada de comunicaciones móviles (4G), se emplearon técnicas ''MIMO'' y ''Smart Antennas. MIMO es un acrónimo que se refiere a ''Multiple Input Multiple Output'', por lo que se podrá utilizar una agrupación de antenas tanto en el emisor como en el receptor. Se puede entender mejor el concepto observando el canal del sistema correspondiente a la \textit{Figura 1.2}. En concreto, es un canal MIMO 4x4.
		
		Debido al uso de múltiples antenas, se pueden emplear las técnicas de multiplexado espacial y diversidad espacial. La primera de ellas consigue mejorar la ganancia mediante la transmisión de distintos flujos de información independientes a través de las múltiples antenas. Esto implica un aumento considerable de la tasa de bits respecto a los sistemas con una única antena. Con la diversidad espacial se incrementa la ganancia en codificación mediante la transmisión de secuencias redundantes por varias antenas.
		
		\begin{figure}[hbtp]
		\centering
		\includegraphics[width = 10cm]{FIGURAS/sistema_MIMO.JPG}
		\caption{Sistema MIMO}
		\end{figure}

		En referencia a la introducción de las llamadas ''Smart Antennas'', son capaces de adaptar el patrón del haz de radiación con el propósito de mejorar la calidad de la señal deseada y minimizar el impacto de la señal interferencia. Esta adaptación implica el uso de beamforming. El beamformer puede ser adaptativo, el cual dirige el haz principal hacia la señal de interés, o conmutado, el cual posee una serie de patrones de radiación fijos. Este fenómeto es levemente ilustrado en la \textit{Figura 1.3}.
		\begin{figure}[hbtp]
		\centering
		\includegraphics[width = 8cm]{FIGURAS/beamformer_adaptativo.JPG}
		\caption{Beamforming en comunicaciones inalámbricas}
		\end{figure}
		
		\subsection{Procesamiento acústico}
		En referencia un punto de vista acústico y manipulación de audio, se van a exponer dos técnicas distintas. La primera será diarización de locutores y la segunda será la localización de fuentes sonoras.
			\subsubsection{Diarización}
			La diarización entre locutores consiste en determinar los instantes de tiempo en los que cada locutor interviene, dada una señal de audio captada con array de micrófonos, como va a ser el caso. Se expone el ejemplo real de una sala de reunión con múltiples locutores y múltiples micrófonos distribuidos en la sala. Para aprovechar la capacidad de un array de múltiples micrófonos, se pueden utilizar técnicas de beamforming, ya explicadas en una sección anterior para realzar la señal de interés.
			
			Antes de ningún proceso que abarque a todos los micrófonos, se debe aplicar un filtro de Wiener a cada canal individual para eliminar el ruido aditivo. Teniendo en cuenta el tiempo de llegada de cada señal y el número total de micrófonos, se implementa un algoritmo que implica correlación cruzada entre señales, obteniendo de esta manera el canal que proporciona una mejor calidad de señal. Tras aplicar beamforming, computando los retrasos entre cada canal, se propone usar el algoritmo de Viterbi, el cual se encarga de hallar el camino o secuencia con mayor probabilidad. El objetivo de este último paso es proporcionar una continuidad a la señal del locutor que está en ese momento hablando, estableciendo el retardo de la señal y filtrando la dirección del haz no deseada.	
			\begin{figure}[hbtp]
			\centering
			\includegraphics[width = 13cm]{FIGURAS/diarizacion.JPG}
			\caption{Decodificación de Viterbi}
			\end{figure}	
			
			En la \textit{Figura 1.4} se esquematiza el algoritmo de Viterbi para un ejemplo de dos locutores, dos fuentes de ruido y micrófonos distribuidos. En el primer paso (b) para cada canal individual, se obtiene los dos mejores caminos en función del tiempo. En el segundo paso (c) se seleccionan los retardos apropiados, considerando todas las posibles combinaciones de todos los canales. Se acaba eligiendo el mejor camino según los datos de distancias y correlación.\linebreak 
			\textit{Nota: Las columnas de la representación trellis del algoritmo de Viterbi corresponden a la diferencia de tiempos de llegada obtenidos anteriormente.
}
			\subsubsection{Localización de fuentes}
			Técnicas de beamforming acústico son usadas para el propósito de localizar fuentes sonoras. Hay que destacar que, las condiciones ambientales pueden afectar considerablemente a la fiabilidad del beamforming. La reflexión y difracción del las ondas sonoras dan lugar a las llamadas ''fuentes fantasma'' o \textit{ghost sources}. Estas \textit{ghost sources} aparecen cuando el proceso de beamforming no está perfectamente adecuado para los fenómenos de propagaciones reales del entorno.
			
			
			\begin{itemize}
				\item[-] Una aplicación interesante de beamforming es la relacionada con la identificación de fuentes en movimiento. En este caso, se debe considerar el efecto Doppler, por lo que se tendrá que compensar este fenómeno. El beamforming aplicado a objetos en movimiento se suele aplicar en el dominio del tiempo, ya que es más rápido para un número grande de micrófonos. Con las coordenadas del móvil estimadas y la frecuencia Doppler compensada, se procede con un beamforming ''delay and sum'', visto en secciones anteriores.
				\item[-] Un campo en el que el beamforming ha supuesto una herramienta de mejora importante es en los experimentos llamados ''Túneles de viento'' o \textit{Wind tunnels}. Estos experimentos se realizan con el propósito de analizar el efecto del aire incidente en objetos. Se simula una situación real, enfocando una estructura como puede ser un avión, una aeronave o incluso edificaciones. 
			\begin{figure}[hbtp]
			\centering
			\includegraphics[width = 12cm]{FIGURAS/wind_tunnel.JPG}
			\caption{Configuración del array para un túnel de viento}
			\end{figure}
			
			Las ondas de sonido radiadas por las fuentes aero-acústicas ubicadas en la superficie del modelo, sufren refracción y scattering debido a entorno del experimento, por lo que deberá existir un algoritmo para compensar este fenómeno. La técnica de beamforming juega un papel importante al estimar las repercusiones acústicas que sufre el modelo y evitar posibles averías o incluso conseguir una mejoría en el comportamiento del modelo. En la \textit{Figura 1.5} se muestra el experimento real (parte de la izquierda) y la disposición de los micrófonos (parte de la derecha).
				\item[-] Por último, mencionar la aplicación de beamforming en interiores. Micrófonos empotrados son normalmente utilizados en entornos de interios, así como cabinas de avión o interiores de automóviles. De esta manera, se consigue identificar la ubicación de las fuentes sonoras y actuar frente a estas.
			\end{itemize}
			
	
	\section{Justificación del proyecto}
	\section{Distribución del proyecto}
		\subsection{Requisitos de realización}
		\subsection{Procedimiento}
		Aquí va una lista de lo que he hecho: servidor, app y algoritmo.
		\subsection{Entornos de trabajo}
		Java, AndroidStudio, Python...
\chapter{Planteamiento del problema}

\chapter{Desarrollo del servidor externo}
	Tal y como se ha comentado, para crear la comunicación con los móviles y manejar las distintas órdenes correspondientes al objetivo de grabar de forma coherente en cada dispositivo, es necesaria la incorporación de un servidor externo.
	
	
		\section{Propósito principal}
			Lo primero, es aclarar la función que el servidor externo va a desempeñar. Su función será dar órdenes a la aplicación así como las de comienzo y finalización de la grabación. Además, será el encargado de, una vez recibidas las grabaciones procedentes de la aplicación, guardar los ficheros correspondientes. Por supuesto, será el encargado de habilitar un puerto disponible para cada dispositivo que se conecte.
			
			
			\subsection{Requisitos funcionales}
				A continuación se van a enumerar los parámetros funcionales a nivel de software que posee el servidor externo creado.
				
				\begin{itemize}
				\item Capacidad para manejar un número máximo de 10 clientes.
				\item La primera conexión de cada cliente se realiza en un mismo puerto común.
				\item Una vez realizada la primera conexión, el servidor maneja los puertos de conexión fija de los clientes, buscando puertos libres, de manera que tengan una asignación consecutiva (ej: nº puerto 5001, 5002, 5003...)
				\item Una vez conectados el número de clientes especificado, esperará la confirmación de la aplicación para enviar la orden de ''comenzar a grabar''
				\item Se le podrá especificar la duración de la grabación en milisegundos.
				\item Una vez acabada la grabación por cada uno de los clientes, se guarda cada fichero de audio en formato de datos brutos (.raw) con la nomenclatura: ''Device'' + ''nº cliente''
				\item El servidor muestra por pantalla las marcas de tiempo correspondientes al inicio y al final de la grabación de cada dispositivo o cliente.
				\item Posee una función la cual reproduce una señal de sincronización una vez hayan comenzado a grabar todos los dispositivos.
				\end{itemize}
			
			\subsection{Requisitos no funcionales}
			En esta parte se va a exponer la calidad del software en sí mismo, con motivo de evaluar su funcionamiento.
			\begin{itemize}
			\item Es necesario especificar el número de conexiones o número de dispositivos que se van a conectar antes de iniciar el servidor.
			\item Una vez iniciado el servidor, espera indefinidamente (timeout) hasta que se realicen el número de conexiones especificadas.
			\item Los tiempos correspondientes a la comunicación entre los diversos dispositivos y el servidor son variables.
			\item Si a la hora de grabar se produce algún problema en uno de los dispositivos, los ficheros correspondientes a los demás dispositivos se guardarán correctamente, mientras que el fichero correspondiente al dispositivo erróneo, no se almacenará de forma correcta.
			\item Los tiempos de respuesta del servidor dentro de una zona de cobertura local rondan los 100 milisegundos.
			\item La comunicación del servidor con los distintos clientes, no se produce de una forma simultánea, sino que genera y recibe información de los dispositivos de uno en uno.
			\item Las marcas temporales devueltas por el servidor son relativas, ya que dependen de la sincronización de los relojes de cada dispositivo en concreto.
			\item Si se desea un tiempo de grabación alto, se deberá aumentar el ''buffer'' correspondiente al amacenamiento de bytes de los archivos de grabación.
			\end{itemize}
		
		\section{Construcción del servidor}
		
			Como ya se ha comentado anteriormente, para la implementación del servidor se ha utilizado el entorno de ''NeatBeans'' debido a la facilidad que proporciona el lenguaje de programación ''java'' con los \textit{sockets} para la comunicación cliente-servidor.
			
			Se va a proporcionar una noción respecto al concepto de \textit{socket} y la típica comunicación cliente-servidor. Acto seguido se verá en detalle cada funcionalidad implementada en el servidor	.
			
			\subsection{Noción general y noción de \textit{socket}}
				Para entender el manejo de los sockets, es necesario conocer la comunicación estándar cliente-servidor.
				
				En una comunicación vía red, la información se desglosa en paquetes. La forma en la que están estructurados estos paquetes, la define el protocolo de transporte utilizado. En el caso que nos concierne, debido a que tenemos el propósito de entablar una comunicación orientada a conexión, se va a utilizar el protocolo TCP (Transfer Control Protocol), complementado con IP (Internet Protocol), formando TCP/IP. Este protocolo utiliza dos piezas claves de identificación: la dirección IP y un número de puerto.
				
				Los términos que hacen referencia a los conceptos de \textit{cliente} y de \textit{servidor} son que el cliente debe iniciar la comunicación, mientras que el servidor espera pasivamente a este primer mensaje por parte del cliente; una vez recibe el servidor el mensaje del cliente, el servidor responde de forma coherente a la petición.

				\begin{figure}[hbtp]
				\centering
				\includegraphics[width = 7cm]{FIGURAS/cliente-servidor.JPG}
				\caption{cliente-servidor}
				\end{figure}
				
				 La distinción \textit{cliente-servidor} es importante porque el cliente necesita conocer la dirección IP y el puerto del servidor, pero no viceversa.
				 
				 En concepto de socket es abstracto. Se puede entender como un método el cual permite la comunicación de aplicaciones en una misma red, pudiendo enviar y recibir datos a través del socket. El protocolo TCP/IP permite transmitir flujos de datos y a través de un socket, una aplicación es capaz de alcanzar un puerto disponible de la red. En la Figura 3.2 se esquematiza la posición de los sockets en el entorno de comunicación.
				 \begin{figure}[hbtp]
				 \centering
				 \includegraphics[width = 10cm]{FIGURAS/Explica_Sockets.JPG}
				 \caption{TCP sockets}
				 \end{figure}	
		El manejo de los sockets en Java lo podemos encontrar en su propia API. 
		\begin{description}
				 \item[Server Socket y Socket:] Se deben inicializar tanto los sockets correspondientes al cliente como los correspondientes al servidor. El socket del servidor o ''Server Socket''  hace referencia al puerto al que debe conectar el cliente para mantener la comunicación con el servidor. El socket perteneciente al cliente o ''Socket'' es el cual se le asigna al cliente por el servidor una vez el cliente haya enviado una request ó petición  mediante el Server Socket. El socket del cliente es de utilidad al propio servidor para manejar al cliente correspondiente y para inicializar este último se necesita además del número de puerto, la dirección IP del servidor.
				 
				 En java, el socket procedente al servidor se inicializa de la siguiente manera:
				 \begin{center}
				 \textit{ServerSocket server = new ServerSocket(Port)}
				 \end{center}
				 El socket correspondiente al cliente:
				 \begin{center}
				 \textit{Socket client = new Socket(IP, Port)}
				 \end{center}
				 
				 \item[InputStream y OutputStream:] La comunicación se realizará mediante flujos de entrada y de salida o también llamados \textit{InputStream} y \textit{OutputStream}. Para transmitir datos en forma de byte, más en específico, se utilizan los flujos \textit{DataOutputStream} y \textit{DataInputStream}. Se corresponden al flujo de salida y al flujo de salida respectivamente. Desde el punto de vista del servidor, el \textit{DataInputStream} va del cliente al servidor y el \textit{DataOutputStream} va del servidor al cliente.
				 
				 La sintaxis en java para inicializar estos puentes es la siguiente:
				 \begin{center}
				 \textit{DataOutputStream  output = new DataOutputStream(client.getOutputStream())}
				 
				 \textit{DataInputStream  input = new DataOutputStream(client.getInputStream())}
				 \end{center}
				 En la salida (\textit{output}) se escribirán bytes para ser enviados y en la entrada (\textit{input}) se leerán los bytes entrantes, valga la redundancia.
				 \end{description}	
				 
				 Teniendo una idea general de los que es un socket y cómo se utiliza, es trivial que en la aplicación a cual se comunica con el servidor poseerá sockets relacionados con el dispositivo en cuestión, para comunicarse correctamente con el servidor y su correspondiente puerto.
				 
				 \subsection{Implementación del servidor}
				 Llegados a este punto, se procede a explicar la arquitectura del propio servidor creado para el proyecto.
				 
				 Lo esperado es manejar 10 clientes, por lo que el servidor podrá crear y dirigir 10 sockets de clientes distintos. Aún así, se han determinado dos conexiones. La primera conexión será común para todos los dispositivos, es decir, debido a esta primera conexión se ha creado un socket de servidor y otro socket de cliente adicionales, los cuales serán estáticos a todos los clientes. Esto significa que cada dispositivo, por primera vez, se conectará a un mismo puerto. Una vez conectado el cliente a este puerto inicial, el servidor le proporcionará al cliente un nuevo puerto de conexión fija, en el cual se llevará a cabo el intercambio final de datos.
				 
				 Para la selección de los números de puertos, hay que tener en cuenta cuáles están en uso y cuáles no, para que no haya ningún tipo de problema. Los puertos del 0 hasta el 1023 están reservados para el sistema operativo y los utilizan protocolos como FTP, DNS, SSH... Por lo que, para asegurar una correcta elección de número de puerto, se establece el puerto fijo de la primera conexión en el número de puerto 5000 y los puertos finales serán el 5001, 5002, 5003, ... 5010. 
				 
				 El servidor creado posee varias funciones, las cuales se enumeran y se explican a continuación:	 	 
				\begin{itemize}
				\item \textbf{Search4port}: Función encargada de devolver una lista de puertos disponibles para iniciar nuevas conexiones. Toma de argumentos de entrada un vector del tipo ''booleano'' donde se indica los puertos ocupados.
				\item \textbf{Recording}: Función encargada de enviar la orden de grabar a cada cliente. Una vez el servidor se encuentre en esta función, deberá recibir el ''ACK'' de todos los clientes para lanzar la orden de grabar. Toma de argumentos de entrada los sockets correspondientes al número de clientes.
				\item \textbf{Delay}: Esta función es la manejadora del tiempo de grabación. Simplemente manda a reposar el hilo principal durante un tiempo determinado, introducido en milisegundos.
				\item \textbf{stopRecording}: Como su propio nombre indica, es la función relacionada con el envío de la orden de parar la grabación. Similar a \textit{Recording} con la diferencia de que se envía la orden opuesta y que el servidor no espera ningún ''ACK'' por parte de los clientes para emitir la orden correspondiente.
				\item \textbf{getTimeStamp}: Función que lee la marca de tiempo devuelta por cada móvil. Como argumento de entrada toma el socket de cada cliente, ya que la marca temporal de cada móvil proviene de la aplicación.
				\item \textbf{Time}: Si fuese necesario devolver una marca temporal ''absoluta'', tomada con el reloj del servidor, se puede llamar a esta función cuando se desee sin argumentos de entrada. Puede ser útil para comparar las demás marcas de tiempo ''relativas'' obtenidas para cada dispositivo.
				\item \textbf{serverImpulse}: Esta función se encarga de emitir un chirp inicial, justo cuando todos los dispositivos están grabando. De esta manera, con la señal inicial captada, se podrá llegar a un algoritmo de sincronización entre las grabaciones efectivo.
				\item \textbf{playChirp}: Para realizar un método de sincronización distinto al comentado en la función anterior, se puede llamar a esta función para emitir una orden de reproducir una señal ''chirp'' en cada uno de los móviles o clientes mientras se encuentran en estado activo de grabación, con el propósito obtener las señales grabadas sincronizadas.
				\item \textbf{saveFiles}: Por último, se llama a esta función. Su principal cometido es recibir los bytes procedentes de cada una de las grabaciones, almacenarlos en un buffer temporal, y guardarlos en la memoria de la máquina en la que se está ejecutando el servidor. Se debe ser coherente con el tiempo de la grabación y el tamaño del buffer temporal. Guarda las grabaciones como archivos de datos en bruto (.raw). Toma de argumentos de entrada el socket de cada cliente.
				\end{itemize}

				
				
		\section{Comunicación}
		
			
			
			
\chapter{Desarrollo de la aplicación }

\chapter{Sincronización}

\chapter{Implementación del algoritmo de Beamforming}

\chapter{Análisis del modelo}

\chapter{Perspectiva de futuro}
Aquí poner lo del 5G, massive MIMO etc Y ALGUNA COSA MÁS.
\chapter{Conclusiones}

\chapter{Bibliografía}

\chapter{Apéndice}





%\input{capitulos/01_Introduccion}
%
%\input{capitulos/02_EspecificacionRequisitos}
%
%\input{capitulos/03_Planificacion}
%
%\input{capitulos/04_Analisis}
%
%\input{capitulos/05_Diseno}
%
%\input{capitulos/06_Implementacion}
%
%\input{capitulos/07_Pruebas}
%
%\input{capitulos/08_Conclusiones}
%
%%\chapter{Conclusiones y Trabajos Futuros}
%
%
%%\nocite{*}
%\bibliography{bibliografia/bibliografia}\addcontentsline{toc}{chapter}{Bibliografía}
%\bibliographystyle{miunsrturl}
%
%\appendix
%\input{apendices/manual_usuario/manual_usuario}
%%\input{apendices/paper/paper}
%\input{glosario/entradas_glosario}
% \addcontentsline{toc}{chapter}{Glosario}
% \printglossary
\chapter*{}
\thispagestyle{empty}

\end{document}
